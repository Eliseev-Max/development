Преимущества:
	* Независимость от API
	* assert vs self.assertEqual (проще по восприятию, меньше запоминать)
	* Параметризованные тесты
	* Плагины
	* Совместимость с unittest и nose
Установка pytest в виртуальное окружение:
	$ python3 -m venv venv
	$ source venv/bin/activate
	$ pip install pytest
Имена тестовых файлов:
	test_*.py
	*_test.py
Имена тестовых классов:
	Test*()		#С заглавной буквы
Имена тестовых функций:
	test*
Pytest требует, чтобы имена тестовых функций начинались с test
Запуск тестов
1. Тесты из текущей директории и всех дочерних (avtodiscovery)
	$ pytest
# команда pytest выполнит все файлы формата test_* или *_test в текущем каталоге и подкаталогах
2. Тесты из файла test_example.py
	$ pytest test_example.py
3. Тесты в классе TestCls из файла test_example.py
	$ pytest test_example.py::TestClass		# Разделитель - двойное двоеточие
4. Тест test_3 из файла test_example.py
	$ pytest test_example.py::test_3
	
pytest -v		подробное представление
(-v повышает детализацию процесса запуска тестов)
 -k	фильтрация по имени теста
 -s	включает вывод stdout и stderr тестов (по умолчанию выводится только для упавших тестов)
 --maxfail = n 	останавливает выполнение после того, как n тестов упало
 --lf, --last-failed	перезапускает тесты, упавшие при последнем запуске
 --ff, --failed-first	запускает все тесты, первыми идут упавшие при последнем запуске
 
В первой строке результата, выводимого pytest, отображаются имя файла и результаты теста
F (FAILED) - неудача при прохождении теста
. (PASSED) - успех при прохождении теста
s (SKIPPED) - тест пропущен (использован декоратор @pytest.mark.skip() или @pytest.mark.skipif())
x (xfail) - не предполагается, что тест будет запущен, завершён успешно или с ошибкой (информация о результатах прохождения теста опускается)
X (XPASS) - не предполагается, что тест не должен быть запущен и пройден успешно
E (ERROR) - исключение произошло вне тестовой функции, либо в фикстуре, либо в hook-функции 
Выполнение подмножества тестов
    1. Выберите тесты для запуска, основываясь на совпадении подстрок имен тестов.
    2. Выберите группы тестов для запуска на основе примененных маркеров.

► Для выполнения тестов, содержащих в своем имени строку, мы можем использовать следующий синтаксис:

	pytest -k <substring> -v
### -k <substring> представляет подстроку для поиска в именах тестов.
Пример:
Тестовые файлы:
	test_K_max_I_Frames.py
	test_104_TESTFR_Act_Con.py
Выполняем команду:
	pytest -k Ack -v
Результат: выполнится только тест: test_104_TESTFR_Act_Con.py

► Pytest - группировка тестов
	Pytest позволяет нам использовать маркеры на тестовых функциях.
	Маркеры используются для установки различных функций / атрибутов для тестирования функций.
	Pytest предоставляет множество встроенных маркеров, таких как xfail, пропуск и параметризация.
	Можно создавать свои собственные имена маркеров.
	Маркеры применяются к тестам с использованием приведенного ниже синтаксиса:
	
		@pytest.mark.<markername>
	
	Чтобы использовать маркеры, мы должны импортировать модуль pytest в тестовый файл.
	Запуск помеченных файлов:
		
		pytest -m <markername> -v		# <markername> - имя маркера тестов
		
	Пример тестового файла
	
		import pytest
		@pytest.mark.great
		def test_greater():
		   num = 100
		   assert num > 100

		@pytest.mark.great
		def test_greater_equal():
		   num = 100
		   assert num >= 100
	
Pytest-светильники
Светильники — это функции, которые запускаются перед каждой тестовой функцией, к которой она применяется.
Светильники используются для подачи некоторых данных в тесты, таких как соединения с базой данных, URL-адреса для тестирования и некоторые виды входных данных.
Поэтому вместо того, чтобы запускать один и тот же код для каждого теста, мы можем прикрепить к тестам функцию фикстуры,
и она будет запускаться и возвращать данные в тест перед выполнением каждого теста.
	
	Пометить функцию как фикстуру:
		@pytest.fixture

Тестовая функция может использовать фикстуру, указав имя функции фикстуры в качестве входного параметра.
	Пример использования фикстуры:
	
	import pytest

	@pytest.fixture
	def input_value():
	   input = 39
	   return input

	def test_divisible_by_3(input_value):		# Подставляет значение, возвращаемое функцией input_value()
	   assert input_value % 3 == 0

	def test_divisible_by_6(input_value):		# Подставляет значение, возвращаемое функцией input_value()
	   assert input_value % 6 == 0
	   
▬ Ограничения:
	Функция фикстуры, определенная в тестовом файле, имеет область действия ТОЛЬКО В ЭТОМ ТЕСТОВОМ ФАЙЛЕ.
	Чтобы сделать фикстуру доступной для нескольких тестовых файлов, мы должны определить функцию фикстуры в файле с именем conftest.py

Pytest ►	Тесты параметризации

Параметризация теста выполняется для запуска теста с несколькими наборами входов.
Мы можем сделать это с помощью следующего маркера —

	@pytest.mark.parametrize

	Пример:
	Файл
____[test_multiplication.py]____
	import pytest

	@pytest.mark.parametrize("num, output",[(1,11),(2,22),(3,35),(4,44)])
	
	def test_multiplication_11(num, output):
		assert 11*num == output
####  Тест имеет 4 набора входных данных, каждый из которых имеет 2 значения:
		одно — это число, которое нужно умножить на 11, а другое — ожидаемый результат.

команда:		Pytest -k multiplication -v

Pytest ►	Xfail/Пропустить тесты

	xfail = pytest выполнит тест, но он не будет считаться частью неудачной или пройденной проверки.
	Детали этих тестов не будут напечатаны, даже если тест не пройден.
	
		@pytest.mark.xfail
	
	skip = пропустить тест
	
		@pytest.mark.skip
		
	Пример:
	
	import pytest
	
	@pytest.mark.xfail			# Тест будет пройден, но никак не будет учтён
	@pytest.mark.great			# Устанавливаем метку для группировки
	def test_greater():
		num = 100
		assert num > 100

	@pytest.mark.xfail			# Тест будет пройден, но никак не будет учтён
	@pytest.mark.great			# Устанавливаем метку для группировки
	def test_greater_equal():
		num = 100
		assert num >= 100

	@pytest.mark.skip			# Тест будет пропущен
	@pytest.mark.others			# Устанавливаем метку для группировки
	def test_less():
		num = 100
		assert num < 200
		
Pytest ►	Остановить тестовый пакет после N тестовых сбоев

	Если требуется остановить выполнение набора тестов после того, как некоторое количество тестов (N) не пройдено.
	Полезная способность для приёмочного (перед релизом) тестирования
	
		pytest --maxfail = <N>		# <N> количество failed-тестов
	
Pytest ►	Запускать тесты параллельно

	По умолчанию pytest запускает тесты последовательно.
	Это увеличивает время прохождения набора тестов.
	
	Для параллельного выполнения тестов
	1. Установить модуль pytest-xdist	(pip install pytest-xdist)
	
	Параллельный запуск тестов:
		pytest -n <Количество_тестов>
		
	Оптимально для больших наборов тестов.
	
Результаты выполнения теста в формате XML

	pytest <Имя_теста> -v --junitxml="result.xml"
	
Резюме:

    Установка pytest
    Определение тестовых файлов и тестовых функций.
    Выполнение всех тестовых файлов с помощью pytest –v.
    Выполнение определенного файла с помощью pytest <filename> -v.
    Выполнить тесты, сопоставив подстроку pytest -k <substring> -v.
    Выполнять тесты на основе маркеров pytest -m <marker_name> -v.
    Создание светильников с использованием @ pytest.fixture.
    conftest.py позволяет получить доступ к приборам из нескольких файлов.
    Параметризация тестов с использованием @ pytest.mark.parametrize.
    Xfailing тесты с использованием @ pytest.mark.xfail.
    Пропуск тестов с использованием @ pytest.mark.skip.
    Остановите выполнение теста при n ошибках, используя pytest —maxfail = <num>.
    Параллельное выполнение тестов с использованием pytest -n <num>.
    Генерация результатов xml с использованием pytest -v —junitxml = «result.xml».

